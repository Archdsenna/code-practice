// 生命周期与引用有效性
//
// 生命周期也是一种泛型: 通过泛型生命周期参数来定义引用间的关系
//
// Rust中每个引用都有其生命周期(lifetime),也就是引用保持有效的作用域
// 生命周期的主要目的是为了避免悬垂引用
//
// 生命周期: 有助于确保引用在我们需要他们的时候一直有效
//
// 生命周期标注语法:
//      生命周期标注并不改变任何引用生命周期的长短,
//      指定了泛型生命周期后,函数也能接受任何生命周期的引用,
//      生命周期标注描述了多个引用生命周期相互的关系,而不影响其生命周期
//
//      标注语法:
//          生命周期标注有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，
//          其名称通常全是小写，类似于泛型其名称非常短。'a 是大多数人默认使用的名称。
//          生命周期参数标注位于引用的 & 之后，并有一个空格来将引用类型与生命周期标注分隔开
//
//           &i32        // 引用
//           &'a i32     // 带有显式生命周期的引用              (一般都是引用才需要生命周期标注,避免悬垂引用)
//           &'a mut i32 // 带有显式生命周期的可变引用
//      注: 单个生命周期标注本身没有多少意义，因为生命周期标注告诉 Rust 多个引用的泛型生命周期参数如何相互联系的


fn main() {
    let str1 = String::from("hello");
    let str2 = "worldddd";
    let longester = longest(str1.as_str(), str2);
    println!("longest string: {}", longester);
}

// fn longest(s1: &str, s2: &str) -> &str {
// 函数签名中生命周期标注(在函数签名中指定生命周期参数时,我们并没有改变任何传入值或返回值的生命周期,
// 而是指出任何不满足这个约束条件的值都将被借用检查器拒绝)
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {   // <'a>这里我们想要告诉Rust,关于参数中的引用和返回值之间的限制是它们都必须拥有相同的生命周期
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}


